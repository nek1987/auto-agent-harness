{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T11:56:09.381Z",
    "slug": "cjharmath-react-performance",
    "source_url": "https://github.com/CJHarmath/claude-agents-skills/tree/main/skills/react-performance",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "6113ae86e2af8a2badf0ec6e566171fe4cdfc2f6ff3759da6b09b13b414fb3f8",
    "tree_hash": "8abd984c302a315f9140c0e2fdb61d3b587b73399cb4e2b3594a6ceb6465265a"
  },
  "skill": {
    "name": "react-performance",
    "description": "Performance optimization for React web applications. Use when optimizing renders, implementing virtualization, memoizing components, or debugging performance issues.",
    "summary": "Performance optimization for React web applications. Use when optimizing renders, implementing virtu...",
    "icon": "⚡",
    "version": "1.0.0",
    "author": "CJHarmath",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "react",
      "performance",
      "optimization",
      "frontend",
      "react-hooks"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure documentation skill containing only markdown content. No executable code, scripts, network calls, filesystem access, or environment variable reads detected. This skill provides only informational guidance for React performance optimization.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 463,
    "audit_model": "claude",
    "audited_at": "2026-01-10T11:56:09.381Z"
  },
  "content": {
    "user_title": "Optimize React performance with proven patterns",
    "value_statement": "React applications often suffer from unnecessary re-renders and slow performance. This skill provides actionable patterns for memoization, virtualization, and render optimization to build fast web applications.",
    "seo_keywords": [
      "React performance optimization",
      "React memoization",
      "React useMemo",
      "React useCallback",
      "list virtualization",
      "React performance patterns",
      "Claude Code",
      "Codex",
      "claude"
    ],
    "actual_capabilities": [
      "Analyze and fix unnecessary React re-renders using useMemo and useCallback",
      "Implement list virtualization for long lists with react-window",
      "Optimize Zustand store selectors to prevent over-rendering",
      "Apply React.memo with custom comparison functions",
      "Debug render issues with React DevTools Profiler",
      "Move heavy computations to web workers"
    ],
    "limitations": [
      "Cannot modify your codebase directly",
      "Cannot run performance profiling tools on your project",
      "Cannot install dependencies or configure build tools",
      "Requires manual implementation of suggested patterns"
    ],
    "use_cases": [
      {
        "target_user": "Frontend developers",
        "title": "Fix slow list rendering",
        "description": "Implement virtualization and memoization for lists with hundreds of items"
      },
      {
        "target_user": "React developers",
        "title": "Debug re-render issues",
        "description": "Diagnose why components re-render and apply proper memoization strategies"
      },
      {
        "target_user": "Full-stack developers",
        "title": "Optimize state management",
        "description": "Fix Zustand selector patterns that cause unnecessary component updates"
      }
    ],
    "prompt_templates": [
      {
        "title": "Memoization basics",
        "scenario": "Optimize expensive calculations",
        "prompt": "How do I use useMemo to optimize an expensive array filter and sort operation in React?"
      },
      {
        "title": "List performance",
        "scenario": "Virtualize long lists",
        "prompt": "Show me how to implement list virtualization with react-window for a list of 500+ items"
      },
      {
        "title": "Callback optimization",
        "scenario": "Prevent child re-renders",
        "prompt": "How do I use useCallback to prevent child components from re-rendering unnecessarily?"
      },
      {
        "title": "Render debugging",
        "scenario": "Debug performance issues",
        "prompt": "How do I use React DevTools Profiler to identify which components are re-rendering too often?"
      }
    ],
    "output_examples": [
      {
        "input": "My React component with a long list is very slow when scrolling",
        "output": [
          "• Implement list virtualization with react-window or react-virtualized",
          "• Wrap list item components with React.memo to prevent unnecessary re-renders",
          "• Use useCallback for event handlers passed to memoized children",
          "• Apply useMemo for expensive data transformations",
          "• Ensure stable object references by defining them outside component or with useMemo"
        ]
      }
    ],
    "best_practices": [
      "Profile before optimizing - use React DevTools Profiler to identify actual bottlenecks",
      "Memoize at the right level - avoid over-memoization which adds more overhead than it saves",
      "Use specific selectors - select only the state your component needs, not the entire store"
    ],
    "anti_patterns": [
      "Creating new objects or functions inline in JSX props passed to memoized children",
      "Memoizing simple operations where the overhead exceeds the benefit",
      "Selecting entire state slices when only specific values are needed"
    ],
    "faq": [
      {
        "question": "What versions of React are supported?",
        "answer": "All patterns work with React 16.8+ which introduced hooks. Some patterns like useMemo and useCallback are available in React 18 and 19."
      },
      {
        "question": "What is the maximum list size for virtualization?",
        "answer": "Virtualization is recommended for lists over 100 items. For lists under 100 items, simple memoization often provides sufficient performance."
      },
      {
        "question": "How does this skill integrate with my project?",
        "answer": "This skill provides guidance and code patterns. You apply the suggestions manually to your React codebase following your existing development workflow."
      },
      {
        "question": "Does this skill access my data or files?",
        "answer": "No. This is a documentation-only skill that provides performance optimization patterns. It does not read, write, or transmit any data."
      },
      {
        "question": "Why is my memoized component still re-rendering?",
        "answer": "Common causes include new object references in props, unstable dependencies in useCallback, or parent component re-renders forcing child updates."
      },
      {
        "question": "How is this different from React.memo?",
        "answer": "useMemo and useCallback memoize values and functions. React.memo memoizes component renders. Use all three together for complete optimization."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
