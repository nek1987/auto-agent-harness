{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-11T03:39:41.662Z",
    "slug": "bossjones-pydantic",
    "source_url": "https://github.com/bossjones/logging-lab/tree/main/.claude/skills/pydantic",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "8469977d985387398c5942df0e710d0a07e9ee66d3d2f1e7384ee68579a2b6e8",
    "tree_hash": "f6c297d795af44711f9b9db751b1f3184a6098090170221b3e9ee5f6306c2312"
  },
  "skill": {
    "name": "pydantic",
    "description": "Data validation and settings management using Python type annotations with Pydantic v2",
    "summary": "Data validation and settings management using Python type annotations with Pydantic v2",
    "icon": "üîç",
    "version": "1.0.0",
    "author": "bossjones",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "validation",
      "pydantic",
      "python",
      "type-safety",
      "data-models"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "external_commands"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "The static analysis findings are false positives. The detected 'Ruby/shell backtick execution' patterns are actually Python code examples showing Pydantic syntax, not actual shell commands. The 'weak cryptographic algorithm' findings are non-existent - the file contains no cryptographic code. This is a documentation skill for Pydantic data validation.",
    "risk_factor_evidence": [
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 15,
            "line_end": 34
          },
          {
            "file": "SKILL.md",
            "line_start": 34,
            "line_end": 38
          },
          {
            "file": "SKILL.md",
            "line_start": 38,
            "line_end": 48
          },
          {
            "file": "SKILL.md",
            "line_start": 48,
            "line_end": 54
          },
          {
            "file": "SKILL.md",
            "line_start": 54,
            "line_end": 70
          },
          {
            "file": "SKILL.md",
            "line_start": 70,
            "line_end": 74
          },
          {
            "file": "SKILL.md",
            "line_start": 74,
            "line_end": 90
          },
          {
            "file": "SKILL.md",
            "line_start": 90,
            "line_end": 94
          },
          {
            "file": "SKILL.md",
            "line_start": 94,
            "line_end": 123
          },
          {
            "file": "SKILL.md",
            "line_start": 123,
            "line_end": 127
          },
          {
            "file": "SKILL.md",
            "line_start": 127,
            "line_end": 160
          },
          {
            "file": "SKILL.md",
            "line_start": 160,
            "line_end": 164
          },
          {
            "file": "SKILL.md",
            "line_start": 164,
            "line_end": 181
          },
          {
            "file": "SKILL.md",
            "line_start": 181,
            "line_end": 185
          },
          {
            "file": "SKILL.md",
            "line_start": 185,
            "line_end": 211
          },
          {
            "file": "SKILL.md",
            "line_start": 211,
            "line_end": 215
          },
          {
            "file": "SKILL.md",
            "line_start": 215,
            "line_end": 239
          },
          {
            "file": "SKILL.md",
            "line_start": 239,
            "line_end": 243
          },
          {
            "file": "SKILL.md",
            "line_start": 243,
            "line_end": 257
          },
          {
            "file": "SKILL.md",
            "line_start": 257,
            "line_end": 261
          },
          {
            "file": "SKILL.md",
            "line_start": 261,
            "line_end": 282
          },
          {
            "file": "SKILL.md",
            "line_start": 282,
            "line_end": 287
          },
          {
            "file": "SKILL.md",
            "line_start": 287,
            "line_end": 289
          },
          {
            "file": "SKILL.md",
            "line_start": 289,
            "line_end": 290
          },
          {
            "file": "SKILL.md",
            "line_start": 290,
            "line_end": 291
          },
          {
            "file": "SKILL.md",
            "line_start": 291,
            "line_end": 295
          },
          {
            "file": "SKILL.md",
            "line_start": 295,
            "line_end": 295
          },
          {
            "file": "SKILL.md",
            "line_start": 295,
            "line_end": 296
          },
          {
            "file": "SKILL.md",
            "line_start": 296,
            "line_end": 298
          },
          {
            "file": "SKILL.md",
            "line_start": 298,
            "line_end": 299
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 302,
    "audit_model": "claude",
    "audited_at": "2026-01-11T03:39:41.662Z"
  },
  "content": {
    "user_title": "Validate data with Pydantic type annotations",
    "value_statement": "Stop debugging data type errors and start catching them before they break your code. Pydantic validates your data structures using Python type annotations, automatically converting and validating inputs with detailed error messages.",
    "seo_keywords": [
      "pydantic",
      "python validation",
      "type annotations",
      "data models",
      "Claude Code",
      "pydantic v2",
      "python typing",
      "data validation",
      "Claude",
      "Codex"
    ],
    "actual_capabilities": [
      "Define data models with automatic type validation",
      "Convert between data formats (JSON, dict, Python objects)",
      "Create custom field validators with decorators",
      "Handle nested models and complex relationships",
      "Generate JSON schemas from models",
      "Validate email addresses and URLs with built-in types"
    ],
    "limitations": [
      "Requires Python 3.8+ for full functionality",
      "Type coercion may hide data quality issues",
      "Complex validation rules can impact performance",
      "Some advanced features require optional dependencies"
    ],
    "use_cases": [
      {
        "target_user": "API developers",
        "title": "Validate API request/response data",
        "description": "Ensure your REST APIs receive and return properly formatted data with automatic validation and clear error messages."
      },
      {
        "target_user": "Data engineers",
        "title": "Structure configuration files",
        "description": "Define strict schemas for YAML/JSON configuration files to catch errors early and provide helpful validation feedback."
      },
      {
        "target_user": "Backend developers",
        "title": "Model database entities",
        "description": "Create type-safe data models that validate business logic before database operations, preventing invalid data storage."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic model validation",
        "scenario": "Create a user registration model",
        "prompt": "Create a Pydantic model for user registration with email, password, age (must be 18+), and username (alphanumeric only). Include proper validation."
      },
      {
        "title": "Nested model structure",
        "scenario": "Build an e-commerce order system",
        "prompt": "Design Pydantic models for an e-commerce order with Customer, Address, Product, and Order models. Include validation for email, phone, and price calculations."
      },
      {
        "title": "Custom validators",
        "scenario": "Validate business rules",
        "prompt": "Create a DateRange model with custom validation ensuring start_date is before end_date, and both dates are in the future. Add helpful error messages."
      },
      {
        "title": "Advanced serialization",
        "scenario": "Control API response format",
        "prompt": "Build a User model with password field that should never be serialized. Add custom serializers for datetime fields and demonstrate different output modes."
      }
    ],
    "output_examples": [
      {
        "input": "Create a Pydantic model for a blog post with title, content, author, and publication date. Add validation for title length and ensure content is not empty.",
        "output": [
          "‚úì Model created with proper field types",
          "‚úì Title validation: min_length=1, max_length=200",
          "‚úì Content validation: prevents empty strings",
          "‚úì Author field: required string",
          "‚úì Publication date: datetime with default to now",
          "‚úì Example usage code provided",
          "‚úì Error handling examples included"
        ]
      }
    ],
    "best_practices": [
      "Always use specific field types like EmailStr instead of plain str for better validation",
      "Wrap model creation in try-except blocks to handle ValidationError gracefully",
      "Use ConfigDict to set model-wide behaviors like strict mode or extra field handling"
    ],
    "anti_patterns": [
      "Don't rely on type coercion to fix bad data - validate inputs at the source",
      "Avoid overly complex nested models that are hard to validate and maintain",
      "Never use Pydantic models for security validation without additional checks"
    ],
    "faq": [
      {
        "question": "What's the difference between Pydantic v1 and v2?",
        "answer": "Pydantic v2 is faster, has better error messages, and uses model_config instead of Config class. Migration requires updating import paths and validator syntax."
      },
      {
        "question": "How do I validate a list of emails?",
        "answer": "Use typing.List[EmailStr] or list[EmailStr] in Python 3.9+. Pydantic validates each item in the list automatically."
      },
      {
        "question": "Can Pydantic validate JSON directly?",
        "answer": "Yes, use model_validate_json() method to parse and validate JSON strings in one step. It returns a validated model instance."
      },
      {
        "question": "How do I exclude fields from serialization?",
        "answer": "Use Field(exclude=True) or model_dump(exclude={'field_name'}). SecretStr fields are automatically excluded."
      },
      {
        "question": "What's the best way to handle optional fields?",
        "answer": "Use Optional[Type] = None or Type | None in Python 3.10+. Set meaningful defaults when possible."
      },
      {
        "question": "Can I use Pydantic with FastAPI?",
        "answer": "Yes, FastAPI has native Pydantic integration. Use Pydantic models for request/response schemas and get automatic validation and documentation."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
