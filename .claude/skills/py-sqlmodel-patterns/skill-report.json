{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T11:53:53.490Z",
    "slug": "cjharmath-py-sqlmodel-patterns",
    "source_url": "https://github.com/CJHarmath/claude-agents-skills/tree/main/skills/py-sqlmodel-patterns",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "b7a406489d4842e3fcee2c87c97c26819f8934ee6a588e2e2230b05d2e36ce44",
    "tree_hash": "9bf08f396294b3e9045c5dba09c08385b85b005c70112cd64ca715163ae2f4ba"
  },
  "skill": {
    "name": "py-sqlmodel-patterns",
    "description": "SQLModel and async SQLAlchemy patterns. Use when working with database models, queries, relationships, or debugging ORM issues.",
    "summary": "SQLModel and async SQLAlchemy patterns. Use when working with database models, queries, relationship...",
    "icon": "ðŸ—„ï¸",
    "version": "1.0.0",
    "author": "CJHarmath",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "python",
      "sqlmodel",
      "sqlalchemy",
      "database",
      "orm"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a documentation-only skill containing markdown patterns and code examples. No executable code, no network calls, no file system access beyond reading the markdown file. Pure prompt-based skill providing SQLModel and async SQLAlchemy best practices.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 332,
    "audit_model": "claude",
    "audited_at": "2026-01-10T11:53:53.490Z"
  },
  "content": {
    "user_title": "Write SQLModel patterns for async databases",
    "value_statement": "SQLModel combines Pydantic and SQLAlchemy, creating confusion about models and schemas. Async SQLAlchemy has different rules than sync. This skill provides tested patterns for eager loading, relationships, sessions, and common database operations.",
    "seo_keywords": [
      "SQLModel patterns",
      "async SQLAlchemy",
      "Python database patterns",
      "SQLModel relationships",
      "SQLModel tutorials",
      "Cluade Code SQLModel",
      "Codex database",
      "ORM best practices",
      "Python async database",
      "SQLModel examples"
    ],
    "actual_capabilities": [
      "Provides eager loading patterns for async relationships",
      "Shows N+1 query detection and prevention methods",
      "Demonstrates model vs schema separation",
      "Explains session state management with expire_on_commit",
      "Covers UUID handling and nullable field patterns",
      "Shows query patterns for CRUD operations"
    ],
    "limitations": [
      "Does not execute code or connect to databases",
      "Does not generate complete project boilerplate",
      "Does not handle migrations or schema changes",
      "Focused on patterns, not full API implementation"
    ],
    "use_cases": [
      {
        "target_user": "Backend developers",
        "title": "Build async database APIs",
        "description": "Create FastAPI endpoints with async SQLAlchemy using proper eager loading and session management."
      },
      {
        "target_user": "Data engineers",
        "title": "Write efficient queries",
        "description": "Avoid N+1 queries and optimize database access patterns in data processing pipelines."
      },
      {
        "target_user": "Python developers",
        "title": "Learn SQLModel patterns",
        "description": "Understand the difference between database models and API schemas in SQLModel projects."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic query patterns",
        "scenario": "Writing CRUD operations",
        "prompt": "Show me how to write a select query to get a user by ID, then update their email, and commit the changes using SQLModel and async session."
      },
      {
        "title": "Eager loading setup",
        "scenario": "Loading related data",
        "prompt": "I have User and Assessment models with a one-to-many relationship. How do I fetch all users with their assessments loaded in a single query using selectinload?"
      },
      {
        "title": "Schema separation",
        "scenario": "Creating API layers",
        "prompt": "Create separate SQLModel classes for a User database table, UserCreate input schema, and UserRead output schema that excludes the password field."
      },
      {
        "title": "Complex relationships",
        "scenario": "Nested data loading",
        "prompt": "I have User -> Assessment -> Question relationships. How do I chain selectinload to eagerly load both assessments and their questions in one query?"
      }
    ],
    "output_examples": [
      {
        "input": "How do I fix 'greenlet_spawn has not been called' error in async SQLAlchemy?",
        "output": [
          "This error occurs when lazy loading is used in async code. Use eager loading instead:",
          "â€¢ For collections (one-to-many): Use selectinload()",
          "â€¢ For single references (many-to-one): Use joinedload()",
          "â€¢ Example: select(User).options(selectinload(User.assessments))"
        ]
      }
    ],
    "best_practices": [
      "Always use selectinload or joinedload for relationships in async code to avoid lazy loading errors.",
      "Separate database models from API schemas to prevent accidentally exposing sensitive fields like passwords.",
      "Use expire_on_commit=False when you need to access objects after commit without refreshing from the database."
    ],
    "anti_patterns": [
      "Using lazy loading with async SQLAlchemy - causes 'greenlet_spawn has not been called' errors.",
      "Exposing database models directly in API responses - may leak hashed_password or other sensitive fields.",
      "Accessing relationships without eager loading causes N+1 queries that slow down applications."
    ],
    "faq": [
      {
        "question": "What versions of SQLModel and SQLAlchemy are supported?",
        "answer": "Patterns work with SQLModel 0.0+ and SQLAlchemy 2.0+. The async patterns require SQLAlchemy 2.0 or newer."
      },
      {
        "question": "What database engines work with these patterns?",
        "answer": "Patterns support PostgreSQL, MySQL, and SQLite with async engines. PostgreSQL examples use psycopg3 for async connections."
      },
      {
        "question": "Can I use these patterns with Django ORM?",
        "answer": "No. These patterns are specific to SQLModel and SQLAlchemy. Django ORM has different methods for eager loading and sessions."
      },
      {
        "question": "Is my data safe when using these patterns?",
        "answer": "Yes. These are read-only patterns for code generation. No data leaves your machine. Patterns help you write safer code that properly separates models from schemas."
      },
      {
        "question": "Why do I get 'greenlet_spawn has not been called'?",
        "answer": "This error happens when lazy loading is used in async code. Lazy loading blocks while waiting for the database. Use selectinload or joinedload to eagerly load relationships instead."
      },
      {
        "question": "How is SQLModel different from plain SQLAlchemy?",
        "answer": "SQLModel combines Pydantic and SQLAlchemy. It uses Pydantic models as SQLAlchemy models. This blurs the line between data validation and database schemas, requiring careful separation of concerns."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
