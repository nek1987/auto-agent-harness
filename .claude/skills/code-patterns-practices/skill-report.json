{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T10:55:52.978Z",
    "slug": "babakbar-code-patterns-practices",
    "source_url": "https://github.com/BabakBar/VibeKeeper/tree/main/.claude/skills/code-patterns",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "3decb198c28d3228c622bee7fcbdf79e6dd65713e5cbc8223d8cca87b01195bd",
    "tree_hash": "783a626db6a4312d1b9ec8685b10fa5086434ba62472a30554fdff34bf7819ce"
  },
  "skill": {
    "name": "Code Patterns & Practices",
    "description": "React Native coding patterns, best practices, and common solutions for mobile development. Use when implementing features or refactoring code.",
    "summary": "React Native coding patterns, best practices, and common solutions for mobile development. Use when ...",
    "icon": "ðŸ“±",
    "version": "1.0.0",
    "author": "BabakBar",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "react-native",
      "mobile-development",
      "patterns",
      "best-practices",
      "typescript"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure documentation skill containing React Native coding patterns and best practices. Uses minimal tool permissions (Read, Write, Edit) appropriate for code guidance. No network access, no scripts, no code execution, no suspicious capabilities.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 337,
    "audit_model": "claude",
    "audited_at": "2026-01-10T10:55:52.978Z"
  },
  "content": {
    "user_title": "Apply React Native Code Patterns",
    "value_statement": "This skill provides React Native coding patterns and best practices for building mobile apps. It helps developers implement common patterns like custom hooks, compound components, and state management solutions.",
    "seo_keywords": [
      "react native patterns",
      "react native best practices",
      "mobile development patterns",
      "typescript react native",
      "react native coding",
      "react native hooks",
      "react native state management",
      "claude code patterns",
      "react native performance",
      "react native components"
    ],
    "actual_capabilities": [
      "Provides custom hook patterns for extracting reusable logic",
      "Shows compound component patterns for flexible APIs",
      "Demonstrates render props for sharing component logic",
      "Explains state management with Context and Zustand",
      "Covers data fetching patterns with async/await",
      "Details performance optimization with memoization and lazy loading"
    ],
    "limitations": [
      "Does not write or test actual code in your project",
      "Does not execute or run React Native applications",
      "Does not provide backend or API implementation",
      "Focused specifically on React Native, not general web patterns"
    ],
    "use_cases": [
      {
        "target_user": "React Native developers",
        "title": "Implement new features",
        "description": "Apply established patterns when building new screens, components, or features in React Native apps."
      },
      {
        "target_user": "Mobile app architects",
        "title": "Choose architecture patterns",
        "description": "Select appropriate state management and component patterns for mobile app architecture decisions."
      },
      {
        "target_user": "Frontend developers new to React Native",
        "title": "Learn React Native patterns",
        "description": "Understand React Native-specific patterns like safe area handling and keyboard avoiding."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic pattern request",
        "scenario": "Need a custom hook",
        "prompt": "Show me how to create a custom hook in React Native for handling toggle state."
      },
      {
        "title": "Component architecture",
        "scenario": "Build flexible component API",
        "prompt": "How do I implement compound components pattern in React Native for tabs navigation?"
      },
      {
        "title": "State management",
        "scenario": "Manage global state",
        "prompt": "What is the best pattern for managing global user state in a React Native app with Zustand?"
      },
      {
        "title": "Performance optimization",
        "scenario": "Optimize slow renders",
        "prompt": "How do I use useMemo and useCallback to optimize performance in a React Native list component?"
      }
    ],
    "output_examples": [
      {
        "input": "How do I create a compound component for tabs in React Native?",
        "output": [
          "â€¢ Create a Tabs component with internal state for active tab",
          "â€¢ Use React Context to share state between parent and child components",
          "â€¢ Expose sub-components (Tabs.List, Tabs.Trigger, Tabs.Content) as static properties",
          "â€¢ Provide defaultValue prop for initial tab selection",
          "â€¢ Example structure enables flexible, declarative tab navigation"
        ]
      }
    ],
    "best_practices": [
      "Keep components small with single responsibility for easier testing and maintenance",
      "Extract reusable logic into custom hooks rather than duplicating code",
      "Handle loading and error states explicitly for better user experience"
    ],
    "anti_patterns": [
      "Avoid massive components over 300 lines that do too many things",
      "Do not pass props through multiple levels (prop drilling); use Context or stores instead",
      "Never mutate state directly; always use setState or state setter functions"
    ],
    "faq": [
      {
        "question": "What React Native versions are supported?",
        "answer": "Patterns work with React Native 0.71+ and Expo SDK 49+. Check compatibility with specific hook dependencies."
      },
      {
        "question": "Can I use these patterns with Expo?",
        "answer": "Yes. All patterns are compatible with Expo managed workflow and bare React Native projects."
      },
      {
        "question": "How do I handle async operations safely?",
        "answer": "Use cancellation flags in useEffect to prevent updates on unmounted components. Check cancelled state before setting state."
      },
      {
        "question": "Is my data safe when using this skill?",
        "answer": "Yes. This is a read-only guidance skill. It only reads your code to provide context-aware suggestions."
      },
      {
        "question": "Why is my component re-rendering too much?",
        "answer": "Check for inline function definitions in JSX. Use useCallback for event handlers and useMemo for expensive calculations."
      },
      {
        "question": "How is this different from React web patterns?",
        "answer": "React Native patterns address mobile-specific concerns like safe area insets, keyboard avoiding, and touch interactions."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
