{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T10:24:26.932Z",
    "slug": "asmayaseen-frontend-types",
    "source_url": "https://github.com/Asmayaseen/hackathon-2/tree/main/.claude/skills/frontend-types",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "263ca88a5ffa388dbb9412716075a4d9c02c9487c8e21a438114ad0e57fffab5",
    "tree_hash": "37add368ef92ce5a30f05b636f66ad53b7dfc55c9211119adc0f0b5128dad10a"
  },
  "skill": {
    "name": "Frontend TypeScript Types Skill",
    "description": "**Purpose**: Guidance for creating TypeScript type definitions following existing patterns from `frontend/types/index.ts`.",
    "summary": "**Purpose**: Guidance for creating TypeScript type definitions following existing patterns from `fro...",
    "icon": "TS",
    "version": "1.0.0",
    "author": "Asmayaseen",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "typescript",
      "frontend",
      "types",
      "type-safety"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure documentation skill containing only markdown guidance and TypeScript code examples. No executable code, no network access, no filesystem access beyond reading this file. Zero risk.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 392,
    "audit_model": "claude",
    "audited_at": "2026-01-10T10:24:26.932Z"
  },
  "content": {
    "user_title": "Define TypeScript types for frontend",
    "value_statement": "Frontend developers need consistent TypeScript type definitions to ensure type safety across the application. This skill provides patterns and conventions for creating types that match backend API responses.",
    "seo_keywords": [
      "TypeScript types",
      "frontend development",
      "type safety",
      "API responses",
      "interface patterns",
      "Claude Code",
      "Claude",
      "Codex",
      "generic types",
      "form data types"
    ],
    "actual_capabilities": [
      "Define interface types for API responses",
      "Create union types for status and priority values",
      "Build generic response types with type parameters",
      "Map backend snake_case fields to frontend camelCase",
      "Create form data and query parameter types",
      "Implement error and toast message types"
    ],
    "limitations": [
      "Does not generate code files automatically",
      "Requires manual implementation in codebase",
      "Does not validate existing types",
      "Does not integrate with build tools"
    ],
    "use_cases": [
      {
        "target_user": "Frontend developers",
        "title": "New type definitions",
        "description": "Creating consistent TypeScript interfaces for new API endpoints"
      },
      {
        "target_user": "Full-stack engineers",
        "title": "Backend schema matching",
        "description": "Ensuring frontend types match backend API response structures"
      },
      {
        "target_user": "TypeScript teams",
        "title": "Codebase standardization",
        "description": "Establishing type naming conventions across the project"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic user types",
        "scenario": "Creating user authentication types",
        "prompt": "Create User, UserCredentials, and UserSignupData interfaces following the skill patterns"
      },
      {
        "title": "API response wrapper",
        "scenario": "Building generic response types",
        "prompt": "Define ApiResponse<T> and PaginatedResponse<T> types with success flag and error handling"
      },
      {
        "title": "Form data types",
        "scenario": "Creating input form types",
        "prompt": "Create TaskFormData and TaskQueryParams types with optional fields marked correctly"
      },
      {
        "title": "Custom entity types",
        "scenario": "Adding new domain entities",
        "prompt": "Define a new Category entity type including form data, query params, and API response types"
      }
    ],
    "output_examples": [
      {
        "input": "Create task-related types for the frontend",
        "output": [
          "TaskStatus type: 'pending' | 'completed'",
          "TaskPriority type: 'low' | 'medium' | 'high'",
          "Task interface with all backend fields (id, user_id, title, description, completed, priority, due_date, tags, created_at, updated_at)",
          "TaskFormData interface with optional description, priority, due_date, tags",
          "TaskQueryParams interface with optional status, sort, search, page, limit"
        ]
      }
    ],
    "best_practices": [
      "Use interface for object types and type for union types",
      "Match backend field names exactly in API response types",
      "Mark optional fields with ? to match backend nullable fields",
      "Create separate form data types with camelCase field names"
    ],
    "anti_patterns": [
      "Mixing interface and type arbitrarily without pattern",
      "Using camelCase for API response types that must match backend",
      "Forgetting to mark truly optional fields",
      "Creating monolithic types instead of separating form data from responses"
    ],
    "faq": [
      {
        "question": "When should I use interface vs type?",
        "answer": "Use interface for object structures and type for union types or aliases. Interfaces support extends for inheritance."
      },
      {
        "question": "How do I handle backend snake_case fields?",
        "answer": "Keep snake_case in API response types. Convert to camelCase only in form data types used by components."
      },
      {
        "question": "Should form data types match API responses?",
        "answer": "No. Form data types only include editable fields and use camelCase. API response types include all backend fields with snake_case."
      },
      {
        "question": "How do I make fields optional in types?",
        "answer": "Add ? after the field name in interfaces. Required fields have no marker."
      },
      {
        "question": "How do I create reusable response types?",
        "answer": "Use generic types like ApiResponse<T> with a default parameter. Pass the specific type when using."
      },
      {
        "question": "What naming convention should I use?",
        "answer": "PascalCase for all types. Use EntityName for objects, EntityNameFormData for forms, EntityNameQueryParams for queries."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
