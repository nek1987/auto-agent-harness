{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T10:15:09.344Z",
    "slug": "agentworkforce-browser-testing-with-screenshots",
    "source_url": "https://github.com/AgentWorkforce/relay/tree/main/.claude/skills/browser-testing-with-screenshots",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "ae394a87b8afb46a999cd51351e84cbb25a5e933aefc1d4f670ba5fa054fcff0",
    "tree_hash": "c348a0500911d8517fe77a30307203edc2cb3cf355c90020be5549bfb3578e93"
  },
  "skill": {
    "name": "browser-testing-with-screenshots",
    "description": "Use when testing web applications with visual verification - automates Chrome browser interactions, element selection, and screenshot capture for confirming UI functionality",
    "summary": "Use when testing web applications with visual verification - automates Chrome browser interactions, ...",
    "icon": "ðŸ§ª",
    "version": "1.0.0",
    "author": "AgentWorkforce",
    "license": "MIT",
    "category": "testing",
    "tags": [
      "browser",
      "testing",
      "automation",
      "screenshots",
      "visual-verification"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure documentation skill containing only markdown instructions for browser automation. No executable code, scripts, or network calls. References external agent-tools that users install separately.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 424,
    "audit_model": "claude",
    "audited_at": "2026-01-10T10:15:09.344Z"
  },
  "content": {
    "user_title": "Automate browser testing with visual verification",
    "value_statement": "Manual browser testing is time-consuming and error-prone. This skill provides automated Chrome browser control through DevTools Protocol for reliable UI verification and screenshot capture.",
    "seo_keywords": [
      "browser testing",
      "Chrome automation",
      "visual verification",
      "screenshot capture",
      "UI testing",
      "end-to-end testing",
      "browser tools",
      "DevTools Protocol",
      "Claude",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Launch Chrome with remote debugging for automation",
      "Navigate to URLs and wait for page load",
      "Capture screenshots of current viewport state",
      "Execute JavaScript in page context for interaction",
      "Extract page content and element selectors",
      "View and manage browser cookies"
    ],
    "limitations": [
      "Requires separate installation of agent-tools from GitHub",
      "Only works with Chrome-based browsers",
      "Cannot test pages behind authentication without credentials",
      "Screenshots capture only current viewport, not full page"
    ],
    "use_cases": [
      {
        "target_user": "Frontend Developers",
        "title": "Verify UI Changes",
        "description": "Test localhost applications by capturing screenshots before and after code changes to catch visual regressions."
      },
      {
        "target_user": "QA Engineers",
        "title": "Visual Test Documentation",
        "description": "Automate end-to-end test scenarios and capture screenshot evidence for test reports and bug documentation."
      },
      {
        "target_user": "Technical Writers",
        "title": "Document Workflows",
        "description": "Generate step-by-step visual guides by automating browser navigation and capturing screenshots at each step."
      }
    ],
    "prompt_templates": [
      {
        "title": "Start Browser",
        "scenario": "Launch Chrome for testing",
        "prompt": "Start a fresh Chrome browser instance with remote debugging for testing."
      },
      {
        "title": "Navigate and Screenshot",
        "scenario": "Test a specific page",
        "prompt": "Navigate to http://localhost:5172/dashboard and take a screenshot to verify the page loaded correctly."
      },
      {
        "title": "Form Interaction Test",
        "scenario": "Test form behavior",
        "prompt": "Navigate to the login page, fill in the username and password fields using browser evaluation, click the login button, and verify the dashboard loads with a screenshot."
      },
      {
        "title": "Visual Regression Check",
        "scenario": "Compare UI states",
        "prompt": "Navigate to the settings page, take a baseline screenshot, make a change, take another screenshot, and compare the visual differences."
      }
    ],
    "output_examples": [
      {
        "input": "Test the login flow by navigating to the login page, taking a screenshot, filling in test credentials, submitting, and capturing the dashboard.",
        "output": [
          "Browser started with fresh profile on port 9222",
          "Navigated to http://localhost:5172/login",
          "Screenshot saved: screenshot_20241201_143052.png",
          "Filled username field with testuser",
          "Filled password field with password123",
          "Clicked login button via element selector",
          "Navigated to http://localhost:5172/dashboard",
          "Dashboard screenshot saved: screenshot_20241201_143115.png",
          "Login flow test complete - 2 screenshots captured"
        ]
      }
    ],
    "best_practices": [
      "Add sleep delays after navigation to ensure page content fully loads before screenshots",
      "Use browser-pick.js for element selection instead of hardcoded CSS selectors",
      "Start browser with --fresh flag only when clean state is needed; use default profile to preserve login sessions"
    ],
    "anti_patterns": [
      "Skipping sleep delays after navigation results in screenshots of loading states",
      "Hardcoding CSS selectors causes tests to break when UI components change",
      "Not checking browser connection before running tests leads to confusing error messages"
    ],
    "faq": [
      {
        "question": "Which browsers are supported?",
        "answer": "This skill works with Chrome and any Chromium-based browser that supports the DevTools Protocol."
      },
      {
        "question": "What are the performance limits?",
        "answer": "Screenshots are captured instantly. Complex pages with many elements may take 1-2 seconds to render fully."
      },
      {
        "question": "How does it integrate with other tools?",
        "answer": "The skill outputs file paths and text that can be used in bash scripts, CI/CD pipelines, or other testing frameworks."
      },
      {
        "question": "Is my browsing data safe?",
        "answer": "The skill runs locally on your machine. No data is sent to external servers. Use --fresh flag for isolated testing."
      },
      {
        "question": "Why am I getting connection refused errors?",
        "answer": "Run browser-start.js first to launch Chrome with debugging. The browser must be running before other commands work."
      },
      {
        "question": "How is this different from Playwright or Cypress?",
        "answer": "This skill provides lightweight browser automation without requiring test framework setup. Best for quick checks and documentation."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
