{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T11:21:50.187Z",
    "slug": "benny9193-code-patterns",
    "source_url": "https://github.com/Benny9193/devflow/tree/master/skills/code-patterns",
    "source_ref": "master",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "b1b9facde043ad8d3dd33c3f1b452d4c26df1bde1ed9da2678a19c4bd4f9a81d",
    "tree_hash": "245bc0bbdef962c7dd4088a3a6bc67ddd2137c27a7d4c7cf6494c09923ba4859"
  },
  "skill": {
    "name": "code-patterns",
    "description": "Common code patterns and best practices reference for quick lookup",
    "summary": "Common code patterns and best practices reference for quick lookup",
    "icon": "ðŸ“‹",
    "version": "1.0.0",
    "author": "Benny9193",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "design-patterns",
      "software-architecture",
      "typescript",
      "best-practices",
      "reference"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure markdown documentation skill with no executable code. Contains only software design pattern references and TypeScript code examples for educational purposes. No scripts, network calls, file system access, or command execution capabilities.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 290,
    "audit_model": "claude",
    "audited_at": "2026-01-10T11:21:50.187Z"
  },
  "content": {
    "user_title": "Apply software design patterns",
    "value_statement": "Writing maintainable code requires knowing proven solutions to common problems. This reference provides ready-to-use pattern implementations for Factory, Builder, Strategy, Observer, and other classic design patterns.",
    "seo_keywords": [
      "software design patterns",
      "TypeScript patterns",
      "Factory pattern",
      "Builder pattern",
      "Strategy pattern",
      "Observer pattern",
      "coding best practices",
      "software architecture",
      "Claude Code patterns",
      "Codex patterns"
    ],
    "actual_capabilities": [
      "Provides Factory pattern for object creation without specifying exact class",
      "Shows Builder pattern for complex object construction with optional parameters",
      "Demonstrates Adapter pattern for making incompatible interfaces work together",
      "Illustrates Strategy pattern for runtime algorithm selection",
      "Implements Observer pattern for event-based state change notifications",
      "Includes error handling patterns like Result type and retry with backoff"
    ],
    "limitations": [
      "Pattern selection requires understanding your specific use case",
      "Examples are TypeScript-focused and may need adaptation for other languages",
      "Patterns are starting points, not rigid templates to follow blindly"
    ],
    "use_cases": [
      {
        "target_user": "Software developers",
        "title": "Apply correct pattern",
        "description": "Quickly find and implement the right design pattern for your coding problem"
      },
      {
        "target_user": "Code reviewers",
        "title": "Validate architecture",
        "description": "Reference patterns when reviewing code for proper architectural design"
      },
      {
        "target_user": "Learning developers",
        "title": "Learn patterns",
        "description": "Study concrete examples of classic software design patterns in TypeScript"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic pattern lookup",
        "scenario": "Need a pattern for object creation",
        "prompt": "Show me the Factory pattern for creating objects without specifying the exact class"
      },
      {
        "title": "Pattern comparison",
        "scenario": "Choosing between patterns",
        "prompt": "What pattern should I use when I need to add behavior dynamically without modifying the original class?"
      },
      {
        "title": "Error handling",
        "scenario": "Handling expected failures",
        "prompt": "Show me the Result type pattern for handling errors that are expected, not exceptional"
      },
      {
        "title": "Async coordination",
        "scenario": "Limiting concurrent operations",
        "prompt": "How do I implement a Promise Queue to limit concurrent async operations?"
      }
    ],
    "output_examples": [
      {
        "input": "Show me the Strategy pattern for payment processing",
        "output": [
          "Define a payment strategy interface with a pay method",
          "Create concrete implementations like CreditCardPayment and PayPalPayment",
          "Inject the strategy into a Checkout class that delegates payment to the selected strategy",
          "Switch strategies at runtime by passing different implementations to Checkout"
        ]
      }
    ],
    "best_practices": [
      "Choose patterns based on actual problems, not speculation about future needs",
      "Understand the trade-offs of each pattern before implementation",
      "Keep patterns simple and adapt them to your specific context"
    ],
    "anti_patterns": [
      "Applying patterns where simple code would suffice",
      "Using Singleton for global state without considering alternatives",
      "Blindly copying pattern code without understanding the rationale"
    ],
    "faq": [
      {
        "question": "Which languages are supported?",
        "answer": "Examples are in TypeScript. Patterns are language-agnostic concepts that apply to most object-oriented languages."
      },
      {
        "question": "How many patterns are included?",
        "answer": "The reference includes 12 common patterns covering creational, structural, behavioral, error handling, async, and data categories."
      },
      {
        "question": "Can I use these patterns in production?",
        "answer": "Yes, these are standard implementations. Adapt them to your codebase style and testing requirements."
      },
      {
        "question": "Does this skill access any files or data?",
        "answer": "No. This is a pure reference skill that provides pattern examples without accessing files or external systems."
      },
      {
        "question": "When should I use Builder over Factory?",
        "answer": "Use Builder when objects have many optional parameters. Use Factory when you create objects of different types from the same family."
      },
      {
        "question": "How is this different from online documentation?",
        "answer": "This skill provides concise, AI-optimized pattern references you can directly copy and adapt without searching online."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
