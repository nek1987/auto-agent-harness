"""
PPT Generator Tool
Converts HTML content (with Tailwind-like classes) into a PowerPoint (.pptx) presentation.
Inspired by free-OKC's slides_generator tool (MIT License).
"""

import os
import datetime
from pathlib import Path
from typing import List, Dict
from bs4 import BeautifulSoup
from pptx import Presentation
from pptx.util import Inches, Pt
from pptx.enum.text import PP_ALIGN
from pptx.dml.color import RGBColor
from pptx.enum.shapes import MSO_SHAPE
from pptx.chart.data import CategoryChartData
from pptx.enum.chart import XL_CHART_TYPE
import requests
import tempfile
import pandas as pd

class PPTGenerator:
    def __init__(self, output_dir: str = "generated_docs/ppt"):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)

    def _add_title(self, slide, title: str):
        title_shape = slide.shapes.add_textbox(Inches(0.5), Inches(0.3), Inches(12.33), Inches(1.0))
        title_tf = title_shape.text_frame
        title_p = title_tf.paragraphs[0]
        title_p.text = title
        title_p.font.size = Pt(36)
        title_p.font.bold = True
        title_p.font.color.rgb = RGBColor(20, 60, 110)
        title_p.alignment = PP_ALIGN.CENTER

    def _create_slide(self, presentation: Presentation, slide_layout, title: str, theme_class: str = ""):
        slide = presentation.slides.add_slide(slide_layout)
        self._apply_theme_from_classes(slide, theme_class)
        if title:
            self._add_title(slide, title)
        return slide

    def _apply_theme_from_classes(self, slide, classes: str):
        """Applies theme based on CSS-like classes."""
        # Defaults
        bg_color = RGBColor(240, 248, 255) # AliceBlue
        accent_color = RGBColor(20, 60, 110) # Deep Blue
        secondary_color = RGBColor(51, 153, 255) # Lighter Blue
        
        # Parse classes
        class_list = classes.split()
        
        if "theme-dark" in class_list:
            bg_color = RGBColor(30, 30, 40)
            accent_color = RGBColor(255, 255, 255)
            secondary_color = RGBColor(100, 200, 255)
        elif "theme-minimal" in class_list:
            bg_color = RGBColor(255, 255, 255)
            accent_color = RGBColor(0, 0, 0)
            secondary_color = RGBColor(200, 200, 200)
        elif "theme-nature" in class_list:
            bg_color = RGBColor(240, 255, 240) # Honeydew
            accent_color = RGBColor(34, 139, 34) # ForestGreen
            secondary_color = RGBColor(144, 238, 144) # LightGreen
            
        # Apply Background
        background = slide.background
        fill = background.fill
        fill.solid()
        fill.fore_color.rgb = bg_color

        # Apply Decorators
        if "theme-minimal" not in class_list:
            # Top Bar
            top_bar = slide.shapes.add_shape(
                MSO_SHAPE.RECTANGLE,
                Inches(0), Inches(0), Inches(13.333), Inches(0.15)
            )
            top_bar.fill.solid()
            top_bar.fill.fore_color.rgb = accent_color
            top_bar.line.fill.background()

            # Footer Line
            footer_line = slide.shapes.add_shape(
                MSO_SHAPE.RECTANGLE,
                Inches(0.5), Inches(7.0), Inches(12.33), Inches(0.02)
            )
            footer_line.fill.solid()
            footer_line.fill.fore_color.rgb = RGBColor(128, 128, 128)
            footer_line.line.fill.background()
            
            # Geometric Shapes for Tech/Default
            if "theme-nature" not in class_list and "theme-dark" not in class_list:
                 # Top-Right decorative shape
                shape = slide.shapes.add_shape(
                    MSO_SHAPE.ISOSCELES_TRIANGLE, 
                    Inches(12.5), Inches(-0.5), Inches(1.5), Inches(1.5)
                )
                shape.rotation = 180
                fill = shape.fill
                fill.solid()
                fill.fore_color.rgb = secondary_color
                fill.transparency = 0.8
                shape.line.fill.background()

                # Bottom-Left decorative shape
                shape = slide.shapes.add_shape(
                    MSO_SHAPE.TRAPEZOID, 
                    Inches(-0.5), Inches(6.8), Inches(4), Inches(1)
                )
                fill = shape.fill
                fill.solid()
                fill.fore_color.rgb = secondary_color
                fill.transparency = 0.8
                shape.line.fill.background()

        # Footer Text
        footer_box = slide.shapes.add_textbox(Inches(10), Inches(7.1), Inches(3), Inches(0.3))
        footer_p = footer_box.text_frame.paragraphs[0]
        footer_p.text = "Generated by N-T-AI"
        footer_p.font.size = Pt(10)
        footer_p.font.color.rgb = RGBColor(150, 150, 150)
        footer_p.alignment = PP_ALIGN.RIGHT

    def _apply_geometric_theme(self, slide):
        # Deprecated, kept for backward compatibility if needed, redirects to new system
        self._apply_theme_from_classes(slide, "theme-tech")

    def _add_table(self, slide, soup_table, left, top, width, height):
        rows = soup_table.find_all("tr")
        if not rows:
            return

        first_row_cells = rows[0].find_all(["td", "th"])
        num_cols = len(first_row_cells)
        num_rows = len(rows)
        if num_cols <= 0 or num_rows <= 0:
            return

        table = slide.shapes.add_table(num_rows, num_cols, Inches(left), Inches(top), Inches(width), Inches(height)).table

        for i, row in enumerate(rows):
            cells = row.find_all(["td", "th"])
            for j, cell in enumerate(cells[:num_cols]):
                text = cell.get_text(strip=True)
                table.cell(i, j).text = text
                if cell.name == "th" and table.cell(i, j).text_frame.paragraphs:
                    table.cell(i, j).text_frame.paragraphs[0].font.bold = True

    def _add_chart(self, slide, soup_table, left, top, width, height, chart_type=XL_CHART_TYPE.COLUMN_CLUSTERED):
        try:
            tables = pd.read_html(str(soup_table))
            if not tables:
                return
            df = tables[0]
            if df.empty or df.shape[1] < 2:
                self._add_table(slide, soup_table, left, top, width, height)
                return

            chart_data = CategoryChartData()
            chart_data.categories = df.iloc[:, 0].astype(str).tolist()
            for col in df.columns[1:]:
                chart_data.add_series(str(col), df[col].tolist())

            slide.shapes.add_chart(
                chart_type,
                Inches(left),
                Inches(top),
                Inches(width),
                Inches(height),
                chart_data,
            )
        except Exception:
            self._add_table(slide, soup_table, left, top, width, height)

    def _parse_slides(self, html: str) -> List[BeautifulSoup]:

        """Parses HTML and extracts slide elements."""
        soup = BeautifulSoup(html, "html.parser")
        # Assuming slides are wrapped in a container with class 'ppt-slide'
        slides = soup.select(".ppt-slide")
        if not slides:
            # Fallback: treat top-level sections or divs as slides if no specific class found
            slides = soup.find_all("section")
            if not slides:
                 # If still nothing, wrap the whole body as one slide (emergency fallback)
                 return [soup]
        return slides

    def _extract_slide_content(self, slide_markup: BeautifulSoup, index: int) -> Dict:
        """Extracts title, paragraphs, list items, and images from a slide's HTML."""
        
        # Extract Title
        title_tag = slide_markup.find(["h1", "h2", "h3"])
        title = title_tag.get_text(strip=True) if title_tag else f"Slide {index + 1}"

        # Extract Content (Paragraphs, Lists, Images)
        # We iterate through children to preserve order
        content_elements = []
        
        # Find all relevant tags in order
        # Use recursive=True (default), but check parents to avoid duplication
        all_elements = slide_markup.find_all(["p", "li", "img", "table"])
        
        for element in all_elements:
            # Skip elements that are inside a table, as the table handler will process them (or at least the table cell content)
            # This prevents <p> inside <td> from being added as a separate text box outside the table.
            if element.find_parent("table"):
                continue

            tag_name = element.name
            
            if tag_name == "img":
                src = element.get("src")
                if src:
                    content_elements.append({"type": "image", "src": src})
            elif tag_name == "table":
                # Check if it should be a chart (e.g., class="chart")
                is_chart = "chart" in element.get("class", [])
                content_elements.append({
                    "type": "chart" if is_chart else "table", 
                    "content": element
                })
            else:
                text = element.get_text(strip=True)
                if not text:
                    continue
                
                # Check for basic styles (bold/color) - simplified
                # For now, we just take the text. 
                # Future: parse style attribute or nested <b>/<strong> tags.
                
                if tag_name == "li":
                    content_elements.append({"type": "bullet", "text": text})
                else:
                    content_elements.append({"type": "text", "text": text})

        return {"title": title, "elements": content_elements}

    def _add_textbox(self, slide, text, left, top, width, height, font_size=18, is_bullet=False):
        """Adds a textbox to the slide."""
        txBox = slide.shapes.add_textbox(Inches(left), Inches(top), Inches(width), Inches(height))
        tf = txBox.text_frame
        tf.word_wrap = True
        
        p = tf.paragraphs[0]
        p.text = text
        p.font.size = Pt(font_size)
        
        if is_bullet:
            p.level = 0 
            # In python-pptx, bullets are properties of the paragraph. 
            # Default textbox doesn't have bullet style by default, needs manual setting or template.
            # We simulate with a character prefix in content for now, or we can try to set it.
            # p.font.name = 'Arial'
        
    def _add_image(self, slide, url, left, top, width, height):
        """Adds an image to the slide (URL or Local Path)."""
        try:
            # Check if it's a local file
            if os.path.exists(url):
                slide.shapes.add_picture(url, Inches(left), Inches(top), width=Inches(width))
                return

            # Download image to temp file
            response = requests.get(url, timeout=10)
            if response.status_code == 200:
                with tempfile.NamedTemporaryFile(delete=False, suffix=os.path.splitext(url)[1] or ".jpg") as tmp:
                    tmp.write(response.content)
                    tmp_path = tmp.name
                
                # Add picture
                slide.shapes.add_picture(tmp_path, Inches(left), Inches(top), width=Inches(width))
                
                # Clean up
                os.remove(tmp_path)
        except Exception as e:
            print(f"Failed to add image {url}: {e}")
            # Add placeholder text
            self._add_textbox(slide, f"[Image load failed: {url}]", left, top, 4, 1)

    def generate_ppt(self, html_content: str, filename: str = None) -> str:
        """
        Generates a PPTX file from the provided HTML content.
        
        Args:
            html_content: The HTML string describing the slides.
            filename: Optional filename. If not provided, a timestamped one will be generated.
            
        Returns:
            The absolute path to the generated PPTX file.
        """
        if not filename:
            timestamp = datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
            filename = f"presentation_{timestamp}.pptx"
            
        if not filename.endswith(".pptx"):
            filename += ".pptx"

        output_path = self.output_dir / filename
        
        presentation = Presentation()
        
        # Set 16:9 Aspect Ratio (13.333 x 7.5 inches)
        presentation.slide_width = Inches(13.333)
        presentation.slide_height = Inches(7.5)
        
        # Use a blank layout (usually index 6 in default template)
        blank_layout_index = 6 
        
        slides_markup = self._parse_slides(html_content)
        
        for i, slide_markup in enumerate(slides_markup):
            # Check if layout exists, otherwise use 0
            if len(presentation.slide_layouts) > blank_layout_index:
                slide_layout = presentation.slide_layouts[blank_layout_index]
            else:
                slide_layout = presentation.slide_layouts[0]
                
            theme_class = ""
            if hasattr(slide_markup, "get"):
                try:
                    theme_class = " ".join(slide_markup.get("class") or [])
                except Exception:
                    theme_class = ""

            slide = self._create_slide(presentation, slide_layout, "", theme_class=theme_class)
            
            content = self._extract_slide_content(slide_markup, i)
            
            self._add_title(slide, content["title"])

            # 2. Layout Logic
            elements = content["elements"]
            has_image = any(e["type"] == "image" for e in elements)
            
            # Simple layout decision:
            # If Image exists -> Split View (Text Left, Image Right)
            # Else -> Full Width Text
            
            if has_image:
                # Two Column Layout
                left_col_x = 1.0
                left_col_w = 6.0
                right_col_x = 7.5
                right_col_w = 5.0
                
                current_top_left = 1.5
                current_top_right = 1.5
                
                for element in elements:
                    elem_type = element["type"]
                    
                    if elem_type == "image":
                        # Put in right column
                        self._add_image(
                            slide, 
                            element["src"], 
                            left=right_col_x, 
                            top=current_top_right, 
                            width=right_col_w, 
                            height=None
                        )
                        current_top_right += 4.0 # Space for image
                        
                    elif elem_type == "table" or elem_type == "chart":
                         # Tables/Charts usually wide, put below or in left if small?
                         # Let's put wide elements at bottom spanning full width if possible,
                         # Or just in left column if it fits.
                         # For now, put in left column to avoid overlap.
                        self._add_table(
                            slide,
                            element["content"],
                            left=left_col_x,
                            top=current_top_left,
                            width=left_col_w,
                            height=2.0,
                        ) if elem_type == "table" else self._add_chart(
                            slide,
                            element["content"],
                            left=left_col_x,
                            top=current_top_left,
                            width=left_col_w,
                            height=3.2,
                        )
                        current_top_left += 3.5
                        
                    else:
                        # Text in left column
                        text = element["text"]
                        is_bullet = elem_type == "bullet"
                        if is_bullet: text = f"• {text}"
                        
                        self._add_textbox(
                            slide, 
                            text, 
                            left=left_col_x, 
                            top=current_top_left, 
                            width=left_col_w, 
                            height=0.6, 
                            font_size=18 if is_bullet else 20,
                            is_bullet=is_bullet
                        )
                        current_top_left += 0.7

            else:
                # Single Column Layout (Centered/Wide)
                current_top = 1.5
                current_left = 1.0
                
                for element in elements:
                    elem_type = element["type"]
                    # No images here by definition (except maybe if logic above failed, but we checked has_image)
                    
                    if elem_type == "table":
                        self._add_table(
                            slide,
                            element["content"],
                            left=current_left,
                            top=current_top,
                            width=11.0,
                            height=2.0,
                        )
                        current_top += 2.2
                    elif elem_type == "chart":
                        self._add_chart(
                            slide,
                            element["content"],
                            left=current_left,
                            top=current_top,
                            width=11.0,
                            height=3.2,
                        )
                        current_top += 3.4
                    else:
                        text = element["text"]
                        is_bullet = elem_type == "bullet"
                        
                        if is_bullet:
                            text = f"• {text}"
                        
                        self._add_textbox(
                            slide, 
                            text, 
                            left=current_left, 
                            top=current_top, 
                            width=11.0, 
                            height=0.6, 
                            font_size=18 if is_bullet else 20,
                            is_bullet=is_bullet
                        )
                        
                        current_top += 0.7 # Increment vertical position
                    
                    # Simple page break logic
                    if current_top > 6.5:
                        slide = self._create_slide(presentation, slide_layout, "", theme_class=theme_class)
                        self._add_title(slide, f"{content['title']}（续）")
                        current_top = 1.5
        
        presentation.save(str(output_path))
        return str(output_path.absolute())

if __name__ == "__main__":
    # Simple test
    generator = PPTGenerator()
    sample_html = """
    <div class="ppt-slide">
        <h1>Welcome to N-T-AI</h1>
        <p>This is a generated presentation.</p>
        <li>Feature 1: AI Chat</li>
        <li>Feature 2: PPT Generation</li>
    </div>
    <div class="ppt-slide">
        <h1>Architecture</h1>
        <p>Backend: FastAPI</p>
        <p>Frontend: Flutter</p>
    </div>
    """
    print(generator.generate_ppt(sample_html))
