{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T11:54:25.910Z",
    "slug": "cjharmath-postgres-patterns",
    "source_url": "https://github.com/CJHarmath/claude-agents-skills/tree/main/skills/postgres-patterns",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "5ffd7ce6d21331c7a256663e9dac4b2ac1ef425cab502644907bee373c25fccc",
    "tree_hash": "8d02ae0772dcea0cded874c014e216bb41e4003e1a8b1e5ca4976ba0558440bc"
  },
  "skill": {
    "name": "postgres-patterns",
    "description": "PostgreSQL patterns for reviewing migrations and writing efficient queries. Use when reviewing Alembic migrations, optimizing queries, or debugging database issues.",
    "summary": "PostgreSQL patterns for reviewing migrations and writing efficient queries. Use when reviewing Alemb...",
    "icon": "üêò",
    "version": "1.0.0",
    "author": "CJHarmath",
    "license": "MIT",
    "category": "data",
    "tags": [
      "postgresql",
      "database",
      "migrations",
      "performance",
      "sql"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a pure prompt-based skill containing only documentation and SQL examples. No executable code, no network calls, no file access, and no external command execution. The content provides PostgreSQL best practices for migration review and query optimization.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 341,
    "audit_model": "claude",
    "audited_at": "2026-01-10T11:54:25.910Z"
  },
  "content": {
    "user_title": "Review PostgreSQL migrations and optimize queries",
    "value_statement": "Alembic generates migrations without understanding PostgreSQL performance implications. This skill provides patterns for reviewing database migrations and writing efficient queries that avoid common performance pitfalls.",
    "seo_keywords": [
      "PostgreSQL patterns",
      "Alembic migration review",
      "database optimization",
      "query performance",
      "SQL best practices",
      "index optimization",
      "PostgreSQL indexes",
      "Claude Code",
      "Clade",
      "Codex"
    ],
    "actual_capabilities": [
      "Review migrations for PostgreSQL-specific issues",
      "Identify missing indexes and optimize index column order",
      "Create partial indexes for filtered queries",
      "Write efficient JSONB queries with proper indexes",
      "Avoid table locks during index creation with CONCURRENTLY",
      "Analyze query performance using EXPLAIN ANALYZE"
    ],
    "limitations": [
      "Does not execute queries against actual databases",
      "Cannot access your database schema directly",
      "Does not generate migration files",
      "Cannot monitor real-time database performance"
    ],
    "use_cases": [
      {
        "target_user": "Backend Developers",
        "title": "Review migration safety",
        "description": "Check new migrations for table locks, missing indexes, and constraint issues before deployment."
      },
      {
        "target_user": "Database Engineers",
        "title": "Optimize query performance",
        "description": "Identify slow queries and apply proper indexing strategies including partial and JSONB indexes."
      },
      {
        "target_user": "DevOps Engineers",
        "title": "Debug database issues",
        "description": "Diagnose connection problems, lock contention, and table size issues using diagnostic queries."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Migration Review",
        "scenario": "Review a new migration",
        "prompt": "Review this Alembic migration for PostgreSQL issues. Check for table locks, missing indexes, and constraint problems: [paste migration code]"
      },
      {
        "title": "Index Optimization",
        "scenario": "Optimize slow queries",
        "prompt": "This query is slow. Design proper indexes including partial indexes if the query filters by specific values: [paste query and table schema]"
      },
      {
        "title": "JSONB Query Tuning",
        "scenario": "Improve JSONB performance",
        "prompt": "Our JSONB queries are slow. Show us how to create proper GIN indexes and expression indexes for this pattern: [describe JSONB query pattern]"
      },
      {
        "title": "Lock Troubleshooting",
        "scenario": "Investigate locking issues",
        "prompt": "Our application is experiencing locks. Show diagnostic queries to identify blocking processes and long-running transactions: [describe symptoms]"
      }
    ],
    "output_examples": [
      {
        "input": "Review this migration for PostgreSQL issues:\n\nop.add_column('users', sa.Column('bio', sa.Text(), nullable=False))",
        "output": [
          "‚ö†Ô∏è WARNING: This migration will LOCK the table on large tables",
          "PROBLEM: Adding a NOT NULL column without a default causes a full table rewrite",
          "BETTER APPROACH (3-step process):",
          "1. Add nullable column first: ALTER TABLE users ADD COLUMN bio TEXT;",
          "2. Backfill data in batches to avoid long locks",
          "3. Add constraint: ALTER TABLE users ALTER COLUMN bio SET NOT NULL;",
          "ALSO: Consider adding an index on bio if you will query by it"
        ]
      }
    ],
    "best_practices": [
      "Always use CREATE INDEX CONCURRENTLY on production tables to avoid locking writes",
      "Use partial indexes when you only query a subset of rows to keep indexes small",
      "Apply the 3-step process when adding NOT NULL columns to existing tables"
    ],
    "anti_patterns": [
      "Using CREATE INDEX without CONCURRENTLY on production databases",
      "Adding indexes on low-cardinality columns alone (like boolean flags)",
      "Using uuid4 as primary keys without considering BRIN indexes or index fragmentation"
    ],
    "faq": [
      {
        "question": "Does this skill connect to my database?",
        "answer": "No. This skill provides patterns and examples. You paste your migration or query code, and it suggests improvements based on PostgreSQL best practices."
      },
      {
        "question": "What PostgreSQL versions are supported?",
        "answer": "Patterns support PostgreSQL 11 and later. CONCURRENTLY indexes and certain ALTER TABLE improvements require PostgreSQL 11+."
      },
      {
        "question": "Can this skill generate migration files?",
        "answer": "No. It reviews existing migrations and suggests improvements. You would apply the recommendations to your Alembic migration files manually."
      },
      {
        "question": "Is my data safe when using this skill?",
        "answer": "Yes. The skill only processes text you paste. No data is stored or transmitted. Nothing leaves your session."
      },
      {
        "question": "Why is my query slow even with indexes?",
        "answer": "Common causes include: index column order mismatch, low-cardinality index columns, missing covering indexes, or index fragmentation with UUID primary keys."
      },
      {
        "question": "How is this different from pgAdmin or pg_stat_statements?",
        "answer": "This skill provides pattern guidance. pgAdmin and pg_stat_statements are monitoring tools. Use this skill for migration review before deployment, and monitoring tools for production troubleshooting."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
