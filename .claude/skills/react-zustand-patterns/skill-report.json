{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T11:49:24.992Z",
    "slug": "cjharmath-react-zustand-patterns",
    "source_url": "https://github.com/CJHarmath/claude-agents-skills/tree/main/skills/react-zustand-patterns",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "63d19a8c1eb5bd893ea4fd66181a9839d9bce1b32a61f56e27f7aad3724cc5d0",
    "tree_hash": "4d447b3fdf59f4e1334da501ee956a702d0d41a62112b774b9db4c608c8b311b"
  },
  "skill": {
    "name": "react-zustand-patterns",
    "description": "Zustand state management patterns for React. Use when working with Zustand stores, debugging state timing issues, or implementing async actions. Works for both React web and React Native.",
    "summary": "Zustand state management patterns for React. Use when working with Zustand stores, debugging state t...",
    "icon": "⚛️",
    "version": "1.0.0",
    "author": "CJHarmath",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "react",
      "zustand",
      "state-management",
      "frontend",
      "patterns"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure documentation skill with no executable code, no network calls, no file system access, and no external command execution. Contains only educational markdown content about Zustand patterns.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 357,
    "audit_model": "claude",
    "audited_at": "2026-01-10T11:49:24.992Z"
  },
  "content": {
    "user_title": "Apply Zustand state management patterns",
    "value_statement": "Zustand's simplicity hides timing complexities that cause subtle bugs. Learn patterns for synchronous set() behavior, stale closure prevention, async actions, and selector optimization to write reliable React state management.",
    "seo_keywords": [
      "zustand patterns",
      "react state management",
      "zustand async actions",
      "react zustand tutorial",
      "zustand debugging",
      "zustand selectors",
      "claude code zustand",
      "react native zustand",
      "zustand middleware",
      "zustand store patterns"
    ],
    "actual_capabilities": [
      "Explain set() synchronous behavior vs React batched renders",
      "Fix stale closure issues using get() after async operations",
      "Implement proper async actions with error handling",
      "Optimize selectors to prevent unnecessary re-renders",
      "Debug state changes with devtools middleware",
      "Use persist middleware for localStorage state"
    ],
    "limitations": [
      "Does not generate new store code from specifications",
      "Does not test or validate existing Zustand implementations",
      "Does not integrate with build tools or IDE plugins",
      "Does not provide runtime performance profiling"
    ],
    "use_cases": [
      {
        "target_user": "React Developers",
        "title": "Fix State Timing Bugs",
        "description": "Debug why components see stale values after set() calls due to React's batched render behavior."
      },
      {
        "target_user": "Full-Stack Engineers",
        "title": "Build Async Store Actions",
        "description": "Implement robust async data fetching with proper loading states, error handling, and race condition prevention."
      },
      {
        "target_user": "Frontend Teams",
        "title": "Optimize Render Performance",
        "description": "Prevent unnecessary re-renders by fixing selectors that return new objects on every render cycle."
      }
    ],
    "prompt_templates": [
      {
        "title": "Understanding set()",
        "scenario": "Confused about state timing",
        "prompt": "Explain how set() works synchronously but React re-renders are batched. Show why getState() returns new values immediately but components might see old values."
      },
      {
        "title": "Stale Closures",
        "scenario": "Async callback issues",
        "prompt": "How do I avoid stale closures in Zustand? Show why data captured in a callback becomes stale after await and how to use get() correctly."
      },
      {
        "title": "Async Actions",
        "scenario": "Building async stores",
        "prompt": "Write a complete async action pattern in Zustand with loading state, error handling, and race condition protection using get() checks."
      },
      {
        "title": "Selector Optimization",
        "scenario": "Fixing re-renders",
        "prompt": "Fix this selector that causes unnecessary re-renders: const data = useStore((s) => ({ name: s.name, count: s.count }))"
      }
    ],
    "output_examples": [
      {
        "input": "Explain why set() is synchronous but my component still shows old values after calling it",
        "output": [
          "• set() updates the Zustand store immediately and synchronously",
          "• getState() will show the new value right after set()",
          "• However, React components only re-render in the next batched update cycle",
          "• The component function re-executes with old props/state until React processes the batch",
          "• Use useStore.getState() directly if you need immediate access outside component renders"
        ]
      }
    ],
    "best_practices": [
      "Always use get() or getState() after any await to ensure fresh state values",
      "Use shallow comparison or multiple selectors to prevent object creation in selectors",
      "Add devtools middleware during development to trace state changes"
    ],
    "anti_patterns": [
      "Relying on closure-captured values after async operations without using get()",
      "Returning new objects from selectors that cause unnecessary component re-renders",
      "Skipping the async keyword on store actions that return promises"
    ],
    "faq": [
      {
        "question": "Is Zustand compatible with React Native?",
        "answer": "Yes. Zustand works identically in React Native. Use persist middleware with asyncStorage for mobile persistence."
      },
      {
        "question": "What Zustand versions are supported?",
        "answer": "Patterns cover both Zustand 4.x and 5.x. Key differences include shallow import location and useShallow hook."
      },
      {
        "question": "How do I debug state changes in production?",
        "answer": "Remove devtools middleware in production builds. Use manual logging with get() for production debugging if needed."
      },
      {
        "question": "Is my data safe with persist middleware?",
        "answer": "Persist middleware stores data in localStorage or AsyncStorage. Avoid persisting sensitive data without encryption."
      },
      {
        "question": "Why do my selectors cause infinite re-renders?",
        "answer": "Selectors returning new objects (like { ...state }) change reference on every render. Use shallow comparison or multiple selectors."
      },
      {
        "question": "How does Zustand compare to Redux?",
        "answer": "Zustand is simpler with less boilerplate. Redux offers more middleware and debugging tools. Both handle async with middleware patterns."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
