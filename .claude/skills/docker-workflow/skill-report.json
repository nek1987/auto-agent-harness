{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T10:44:05.801Z",
    "slug": "autumnsgrove-docker-workflow",
    "source_url": "https://github.com/AutumnsGrove/ClaudeSkills/tree/master/docker-workflow",
    "source_ref": "master",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "a8c80486f5cdf484c8443cfc96317c8bc305efd9b495700ae5c956ff9f0b361d",
    "tree_hash": "aeedeb50f4af698e24e20e55d7f195e7af0ea2f4f99540eb04ce24ffcd3dc257"
  },
  "skill": {
    "name": "docker-workflow",
    "description": "Comprehensive Docker containerization workflow covering multi-stage builds, docker-compose orchestration, image optimization, debugging, and production best practices. Use when containerizing applications, setting up development environments, or deploying with Docker.",
    "summary": "Comprehensive Docker containerization workflow covering multi-stage builds, docker-compose orchestra...",
    "icon": "üê≥",
    "version": "1.0.0",
    "author": "AutumnsGrove",
    "license": "MIT",
    "category": "devops",
    "tags": [
      "docker",
      "containers",
      "devops",
      "deployment",
      "orchestration"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "external_commands",
      "scripts"
    ]
  },
  "security_audit": {
    "risk_level": "low",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Documentation and Docker utility script for container management. Executes Docker CLI commands locally for health checks, inspection, and debugging. No network calls, no user filesystem access, no credential exposure. Risk is limited to standard Docker operations for containerized applications.",
    "risk_factor_evidence": [
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "scripts/docker_helper.sh",
            "line_start": 77,
            "line_end": 545
          }
        ]
      },
      {
        "factor": "scripts",
        "evidence": [
          {
            "file": "scripts/docker_helper.sh",
            "line_start": 1,
            "line_end": 546
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [
      {
        "title": "Backup function creates directories",
        "description": "The backup_volumes function (lines 382-422) creates directories using `mkdir -p \"$dest\"`. This is a standard operation for backup functionality. An attacker with control over the destination path could create directories in unintended locations. This is a minor file system manipulation risk.",
        "locations": [
          {
            "file": "scripts/docker_helper.sh",
            "line_start": 407,
            "line_end": 407
          }
        ]
      }
    ],
    "dangerous_patterns": [],
    "files_scanned": 6,
    "total_lines": 2499,
    "audit_model": "claude",
    "audited_at": "2026-01-10T10:44:05.800Z"
  },
  "content": {
    "user_title": "Containerize applications with Docker",
    "value_statement": "Package applications into portable, reproducible containers for consistent development and deployment. Build optimized images with multi-stage builds, orchestrate multi-container applications, and deploy with confidence.",
    "seo_keywords": [
      "docker",
      "docker containerization",
      "multi-stage builds",
      "docker-compose",
      "docker image optimization",
      "container debugging",
      "docker deployment",
      "claude code",
      "claude",
      "codex"
    ],
    "actual_capabilities": [
      "Create optimized Dockerfiles using multi-stage builds",
      "Orchestrate multi-container applications with docker-compose",
      "Debug containers with health checks and inspection utilities",
      "Optimize image size through layer caching and best practices",
      "Configure environment-specific deployments",
      "Apply production security hardening techniques"
    ],
    "limitations": [
      "Requires Docker to be installed on the system",
      "Cannot execute containers directly, requires Docker CLI",
      "Does not manage Kubernetes or container registries"
    ],
    "use_cases": [
      {
        "target_user": "DevOps engineers",
        "title": "Standardize deployment pipelines",
        "description": "Create consistent container images for CI/CD pipelines with security hardening and optimized builds."
      },
      {
        "target_user": "Full-stack developers",
        "title": "Set up local development",
        "description": "Configure development environments with hot-reload, volume mounting, and multi-service orchestration."
      },
      {
        "target_user": "Platform engineers",
        "title": "Design production infrastructure",
        "description": "Build production-ready containers with health checks, resource limits, and rolling deployment strategies."
      }
    ],
    "prompt_templates": [
      {
        "title": "Create a Dockerfile",
        "scenario": "Containerizing a new application",
        "prompt": "Create a multi-stage Dockerfile for a [language: Node.js, Python, Go, Java] application. Include security best practices, non-root user, and health checks."
      },
      {
        "title": "Configure services",
        "scenario": "Setting up multi-container applications",
        "prompt": "Create a docker-compose.yml for a [application type: full-stack, microservices] with [services: frontend, backend, database, cache]. Include networking, health checks, and environment configuration."
      },
      {
        "title": "Optimize images",
        "scenario": "Reducing image size",
        "prompt": "Review and optimize this Dockerfile to reduce image size. Suggest multi-stage build improvements, smaller base images, and layer caching strategies."
      },
      {
        "title": "Debug containers",
        "scenario": "Troubleshooting container issues",
        "prompt": "Container [container_name] is [issue: exiting, unhealthy, not responding]. Show commands to diagnose the issue and suggest fixes based on health check and logs."
      }
    ],
    "output_examples": [
      {
        "input": "Create a Dockerfile for a Node.js Express API with PostgreSQL",
        "output": [
          "‚úì Multi-stage build with builder and production stages",
          "‚úì Non-root user (nodejs:1001) for security",
          "‚úì Health check configured on port 3000",
          "‚úì .dockerignore excludes node_modules and sensitive files",
          "‚úì Alpine base image (~180MB final size)",
          "‚úì Environment variables for configuration"
        ]
      }
    ],
    "best_practices": [
      "Use specific base image versions instead of 'latest' tag for reproducible builds",
      "Run containers as non-root users to limit privilege escalation risks",
      "Implement health checks to enable reliable orchestration and graceful restarts"
    ],
    "anti_patterns": [
      "Copying entire project directory before installing dependencies (invalidates cache)",
      "Including sensitive files or credentials in the build context",
      "Using 'latest' base image tags without version pinning"
    ],
    "faq": [
      {
        "question": "Which programming languages are supported?",
        "answer": "Docker workflows support any language. Templates provided for Node.js, Python, Go, Java, Rust, and general multi-stage builds."
      },
      {
        "question": "What are the image size limits?",
        "answer": "Multi-stage builds typically reduce images by 50-90 percent. Node.js alpine images are around 180MB. Go scratch images can be under 15MB."
      },
      {
        "question": "Does this skill integrate with Kubernetes?",
        "answer": "This skill focuses on Docker and docker-compose. Kubernetes deployment patterns require separate configuration and tools."
      },
      {
        "question": "Is my data safe inside containers?",
        "answer": "Data in containers is ephemeral unless persisted with volumes. Use docker volumes for databases. Never store credentials in images."
      },
      {
        "question": "Why is my container exiting immediately?",
        "answer": "Common causes: missing CMD/ENTRYPOINT, application crash, port binding issues. Use docker logs and docker inspect to diagnose."
      },
      {
        "question": "How does this compare to container orchestration platforms?",
        "answer": "Docker-compose manages local multi-container apps. Orchestration platforms like Kubernetes handle production deployment, scaling, and networking across clusters."
      }
    ]
  },
  "file_structure": [
    {
      "name": "examples",
      "type": "dir",
      "path": "examples",
      "children": [
        {
          "name": "docker-compose.yml",
          "type": "file",
          "path": "examples/docker-compose.yml"
        },
        {
          "name": "Dockerfile.multi-stage",
          "type": "file",
          "path": "examples/Dockerfile.multi-stage"
        }
      ]
    },
    {
      "name": "scripts",
      "type": "dir",
      "path": "scripts",
      "children": [
        {
          "name": "docker_helper.sh",
          "type": "file",
          "path": "scripts/docker_helper.sh"
        }
      ]
    },
    {
      "name": "README.md",
      "type": "file",
      "path": "README.md"
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
