{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T11:50:34.697Z",
    "slug": "cjharmath-py-fastapi-patterns",
    "source_url": "https://github.com/CJHarmath/claude-agents-skills/tree/main/skills/py-fastapi-patterns",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "01641d4cda431f560cb7a1799a5fe563e710db727368fd98ce3dfd854a1590c4",
    "tree_hash": "3093e5369b921e41f57ead49b10ffb9142fa53e54f27c5a7929617895c4d23a5"
  },
  "skill": {
    "name": "py-fastapi-patterns",
    "description": "FastAPI patterns for API design. Use when creating endpoints, handling dependencies, error handling, or working with OpenAPI schemas.",
    "summary": "FastAPI patterns for API design. Use when creating endpoints, handling dependencies, error handling,...",
    "icon": "üêç",
    "version": "1.0.0",
    "author": "CJHarmath",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "python",
      "fastapi",
      "api-design",
      "backend",
      "openapi"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure prompt-based skill containing only documentation and Python code examples. No executable code, scripts, network calls, file system access, or environment variable access detected.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 387,
    "audit_model": "claude",
    "audited_at": "2026-01-10T11:50:34.697Z"
  },
  "content": {
    "user_title": "Apply FastAPI Best Practices",
    "value_statement": "Building APIs with FastAPI requires understanding dependency injection, response models, and OpenAPI schema design. This skill provides battle-tested patterns that prevent common bugs and improve developer experience for frontend teams.",
    "seo_keywords": [
      "FastAPI patterns",
      "Python API development",
      "FastAPI dependency injection",
      "OpenAPI schema",
      "API design best practices",
      "FastAPI error handling",
      "Claude Code",
      "Claude",
      "Codex",
      "Pydantic models"
    ],
    "actual_capabilities": [
      "Implement dependency injection with FastAPI Depends",
      "Create proper response models to filter sensitive data",
      "Handle errors with HTTPException and custom handlers",
      "Design clean OpenAPI schemas with descriptions",
      "Organize routes with APIRouter prefixes and tags",
      "Validate request bodies with Pydantic Field validators"
    ],
    "limitations": [
      "Does not generate complete API projects or boilerplate",
      "Does not integrate with specific databases or ORMs",
      "Does not provide runtime execution or testing capabilities",
      "Focuses on patterns rather than complete implementation examples"
    ],
    "use_cases": [
      {
        "target_user": "Backend Python Developers",
        "title": "Build Maintainable APIs",
        "description": "Apply dependency chains and response models to create APIs that are easy to maintain and evolve over time."
      },
      {
        "target_user": "Full-Stack Developers",
        "title": "Improve Frontend Integration",
        "description": "Design OpenAPI schemas that generate accurate TypeScript types for frontend code generation tools."
      },
      {
        "target_user": "API Architects",
        "title": "Standardize Team Patterns",
        "description": "Establish consistent error handling and route organization across multiple API services."
      }
    ],
    "prompt_templates": [
      {
        "title": "Dependency Injection",
        "scenario": "Setting up authentication dependencies",
        "prompt": "Show me how to create a dependency chain in FastAPI for authentication. Include get_session, get_current_user, and get_current_active_user dependencies that can be used in endpoints."
      },
      {
        "title": "Response Models",
        "scenario": "Protecting sensitive data",
        "prompt": "Explain how to use response_model in FastAPI to prevent exposing internal fields like hashed_password. Show a User model with read and create variants."
      },
      {
        "title": "Error Handling",
        "scenario": "Creating consistent error responses",
        "prompt": "How do I create custom exception handlers in FastAPI that return consistent error responses with error codes? Include both the exception class and the handler."
      },
      {
        "title": "Route Ordering",
        "scenario": "Avoiding route conflicts",
        "prompt": "Explain why route ordering matters in FastAPI. Show an example of how putting /users/me before /users/{user_id} prevents matching issues."
      }
    ],
    "output_examples": [
      {
        "input": "Create a paginated response model for listing assessments",
        "output": [
          "Define a generic PaginatedResponse class with items, total, page, and size fields",
          "Use response_model=PaginatedResponse[AssessmentRead] on the list endpoint",
          "FastAPI automatically filters the response to only include AssessmentRead fields",
          "The OpenAPI schema will correctly document the nested structure"
        ]
      }
    ],
    "best_practices": [
      "Always define specific routes before generic parameterized routes to prevent incorrect matching",
      "Use response_model on every endpoint to control output and generate accurate OpenAPI schemas",
      "Chain dependencies from most generic (session) to most specific (current_user) for reusability"
    ],
    "anti_patterns": [
      "Omitting response_model exposes internal fields like hashed_password in API responses",
      "Placing generic routes before specific routes causes /users/me to be captured as a user_id parameter",
      "Using bare except clauses or generic HTTPException without status codes creates inconsistent error responses"
    ],
    "faq": [
      {
        "question": "Does this skill work with FastAPI async endpoints?",
        "answer": "Yes. All patterns support both sync and async endpoint definitions. Dependencies can be async functions using await."
      },
      {
        "question": "What Python versions are supported?",
        "answer": "FastAPI requires Python 3.8 or later. Most patterns work with Python 3.9+ features like the | type union operator."
      },
      {
        "question": "Can I use these patterns with other frameworks?",
        "answer": "The dependency injection concept applies to other frameworks. Response models and OpenAPI patterns are FastAPI-specific."
      },
      {
        "question": "Is my data safe when using these patterns?",
        "answer": "Yes. This skill contains only documentation patterns. No data leaves your environment when applying these practices."
      },
      {
        "question": "Why am I getting 422 validation errors?",
        "answer": "Pydantic v2 is strict by default. Check that your request body matches all Field validators including min_length and max_length constraints."
      },
      {
        "question": "How does this compare to Django REST Framework?",
        "answer": "FastAPI provides automatic OpenAPI generation and native async support. DRF has more built-in viewsets but requires more configuration for API docs."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
