{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T10:23:31.623Z",
    "slug": "agentworkforce-implementing-command-palettes",
    "source_url": "https://github.com/AgentWorkforce/relay/tree/main/.claude/skills/implementing-command-palettes",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "9d05b15a6cb28d5ecbd92d5eda3c68c533c0fd72464db2a7588e5c22af46d5ef",
    "tree_hash": "844d3f44f796a10812ee6cfb6514f8b11bc0be37b704fc24ca222064134384c1"
  },
  "skill": {
    "name": "implementing-command-palettes",
    "description": "Use when building Cmd+K command palettes in React - covers keyboard navigation with arrow keys, keeping selected items in view with scrollIntoView, filtering with shortcut matching, and preventing infinite re-renders from reference instability",
    "summary": "Use when building Cmd+K command palettes in React - covers keyboard navigation with arrow keys, keep...",
    "icon": "⌨️",
    "version": "1.0.0",
    "author": "AgentWorkforce",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "react",
      "ui-components",
      "accessibility",
      "keyboard-navigation"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a prompt-based documentation skill containing only markdown and React/TypeScript code examples. No executable code, scripts, network calls, or file system access. Contains only documentation patterns for building command palettes.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 345,
    "audit_model": "claude",
    "audited_at": "2026-01-10T10:23:31.623Z"
  },
  "content": {
    "user_title": "Build accessible command palettes in React",
    "value_statement": "Command palettes need careful keyboard handling and scroll behavior to feel responsive. This skill provides battle-tested patterns for arrow navigation, scroll-into-view, shortcut matching, and preventing infinite re-renders.",
    "seo_keywords": [
      "cmd+k palette react",
      "keyboard navigation react",
      "command palette ui",
      "react accessibility",
      "scrollintoview react",
      "claude code",
      "claude",
      "codex",
      "react components",
      "keyboard shortcuts"
    ],
    "actual_capabilities": [
      "Implement arrow key navigation with index tracking and bounds clamping",
      "Keep selected items visible using scrollIntoView with nearest block",
      "Filter commands by label text AND keyboard shortcuts with space stripping",
      "Prevent infinite re-renders using stable icon references and useCallback",
      "Handle keyboard events with window listeners and input autoFocus",
      "Structure command items with action, navigation, file, and PR types"
    ],
    "limitations": [
      "Provides patterns only, requires React project setup",
      "Does not include pre-built component library",
      "Does not handle mobile touch interactions",
      "Focused on keyboard navigation, not voice or switch access"
    ],
    "use_cases": [
      {
        "target_user": "Frontend developers",
        "title": "Build editor command palettes",
        "description": "Create VS Code-style command palettes for text editors with keyboard-driven item selection."
      },
      {
        "target_user": "SaaS application teams",
        "title": "Add site-wide quick actions",
        "description": "Implement Cmd+K menus for quick navigation, search, and actions across web applications."
      },
      {
        "target_user": "React library authors",
        "title": "Create palette components",
        "description": "Build reusable command palette components with proper accessibility and performance patterns."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic palette",
        "scenario": "Building a simple command palette",
        "prompt": "I need to build a command palette with arrow key navigation. Show me the keyboard event handling with selectedIndex tracking and how to prevent page scrolling on arrow keys."
      },
      {
        "title": "Scroll behavior",
        "scenario": "Keeping items visible during navigation",
        "prompt": "My command palette list is long. How do I keep the selected item visible using scrollIntoView with the nearest block option?"
      },
      {
        "title": "Shortcut matching",
        "scenario": "Filtering by keyboard shortcuts",
        "prompt": "I want users to type shortcut sequences like 'gd' to match commands with keyboard shortcuts like 'g d'. Show me the filtering logic with space stripping."
      },
      {
        "title": "Prevent re-renders",
        "scenario": "Fixing infinite re-render loops",
        "prompt": "My command palette causes maximum update depth exceeded errors. Show me how to use stable icon references, useCallback, and label-based change detection."
      }
    ],
    "output_examples": [
      {
        "input": "Build a command palette with arrow navigation and scroll behavior",
        "output": [
          "Arrow navigation uses selectedIndex state with Math.min/max for bounds",
          "scrollIntoView with block: 'nearest' keeps items visible without jarring jumps",
          "Window-level keydown listener handles arrows while input handles text",
          "Use autoFocus on input instead of setTimeout focus",
          "Wrap palette in conditional component to prevent effects running when closed"
        ]
      }
    ],
    "best_practices": [
      "Use wrapper component pattern to ensure effects only run when palette is visible",
      "Define icon elements outside components to maintain stable references",
      "Reset selectedIndex to zero when query changes to start from top"
    ],
    "anti_patterns": [
      "Placing conditional return after useEffect hooks causes effects to run when closed",
      "Using block: 'center' causes jarring scroll even when item is already visible",
      "Defining icons inside useMemo creates new elements every render triggering loops"
    ],
    "faq": [
      {
        "question": "What React hooks are required for command palettes?",
        "answer": "useState for selectedIndex, useEffect for keyboard listeners, useRef for item references, and useCallback/useMemo for stable references."
      },
      {
        "question": "How many items can a command palette handle efficiently?",
        "answer": "Hundreds of items work well. For thousands, consider virtualization but the core patterns remain the same."
      },
      {
        "question": "Does this work with React 18 concurrent features?",
        "answer": "Yes. The patterns use standard hooks that work correctly with React 18's concurrent rendering and useEffect timing."
      },
      {
        "question": "Is user data sent anywhere when using these patterns?",
        "answer": "No. These are purely local React patterns for UI behavior. No network calls or data transmission occur."
      },
      {
        "question": "Why does my palette freeze when I type fast?",
        "answer": "Likely re-render loop from unstable references. Define icons outside component and use useCallback for action handlers."
      },
      {
        "question": "How is this different from libraries like cmdk?",
        "answer": "This skill teaches the underlying patterns so you understand why things work. Libraries handle edge cases; this skill teaches you to build or customize them."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
