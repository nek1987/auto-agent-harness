{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T11:57:27.904Z",
    "slug": "cjharmath-py-async-patterns",
    "source_url": "https://github.com/CJHarmath/claude-agents-skills/tree/main/skills/py-async-patterns",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "1068d9843498d52aa6a65702f5579ea60e08300dc3b4d4e48c7a896737410ae3",
    "tree_hash": "49a2ff6df644d016ab3940bde6f82b3f2d10f52c94fa77b3171aa79cdd1eb6c0"
  },
  "skill": {
    "name": "py-async-patterns",
    "description": "Async/await patterns for FastAPI and SQLAlchemy. Use when working with async code, database sessions, concurrent operations, or debugging async issues in Python.",
    "summary": "Async/await patterns for FastAPI and SQLAlchemy. Use when working with async code, database sessions...",
    "icon": "⚡",
    "version": "1.0.0",
    "author": "CJHarmath",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "async",
      "python",
      "fastapi",
      "sqlalchemy",
      "database"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure documentation skill containing markdown patterns and code examples. No executable code, scripts, network calls, filesystem access, or command execution. Completely safe prompt-based skill.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 359,
    "audit_model": "claude",
    "audited_at": "2026-01-10T11:57:27.904Z"
  },
  "content": {
    "user_title": "Apply Python Async Patterns",
    "value_statement": "Async Python code often suffers from race conditions, session leaks, and connection pool issues. This skill provides battle-tested patterns for FastAPI and SQLAlchemy that prevent common async pitfalls.",
    "seo_keywords": [
      "python async",
      "async await patterns",
      "fastapi async",
      "sqlalchemy async",
      "asyncio best practices",
      "async database",
      "concurrent python",
      "claude async code",
      "codex async python",
      "claude-code async"
    ],
    "actual_capabilities": [
      "Guide AsyncSession lifecycle management and dependency injection",
      "Optimize concurrent versus sequential database queries",
      "Implement proper transaction boundaries with commit and rollback",
      "Configure connection pool settings for asyncpg compatibility",
      "Use BackgroundTasks for non-blocking post-response operations",
      "Prevent deadlocks with consistent lock ordering"
    ],
    "limitations": [
      "Does not generate new async code from scratch",
      "Does not execute or test async code",
      "Does not modify existing codebase files",
      "Does not integrate with async debugging tools"
    ],
    "use_cases": [
      {
        "target_user": "Backend Developer",
        "title": "Fix Session Leaks",
        "description": "Identify and resolve async session management issues that cause stale data and connection exhaustion."
      },
      {
        "target_user": "API Engineer",
        "title": "Optimize Query Performance",
        "description": "Transform sequential database queries into parallel operations using asyncio.gather for faster endpoints."
      },
      {
        "target_user": "Full-Stack Developer",
        "title": "Implement Safe Transactions",
        "description": "Handle multi-step database operations with proper commit, rollback, and refresh patterns."
      }
    ],
    "prompt_templates": [
      {
        "title": "Session Management",
        "scenario": "Fix session lifecycle issues",
        "prompt": "Help me fix session lifecycle issues in my FastAPI app. I am seeing 'Session is closed' errors and connection timeouts."
      },
      {
        "title": "Query Optimization",
        "scenario": "Parallelize database queries",
        "prompt": "I have multiple independent database queries in my endpoint that are running slowly. Show me how to use asyncio.gather to run them in parallel."
      },
      {
        "title": "Transaction Safety",
        "scenario": "Handle complex transactions",
        "prompt": "I need to implement a multi-step transfer operation between accounts. Show me the correct pattern for transactions with commit, rollback, and refresh."
      },
      {
        "title": "Background Operations",
        "scenario": "Offload slow tasks",
        "prompt": "My endpoint is slow because it sends emails and updates analytics after processing. Show me how to use BackgroundTasks or asyncio.create_task for non-blocking operations."
      }
    ],
    "output_examples": [
      {
        "input": "Help me fix session lifecycle issues in my FastAPI app. I am seeing 'Session is closed' errors and connection timeouts.",
        "output": [
          "Session lifecycle issues typically occur when the session is used outside its request scope. Here is the correct pattern:",
          "✅ Use dependency injection with FastAPI's Depends to scope sessions to each request",
          "✅ Always use async context managers: async with async_session() as session",
          "✅ Never store sessions in global variables or module-level state",
          "✅ Return sessions from dependency functions that yield to the request handler",
          "The session automatically closes when the request completes, preventing leaks and stale data issues."
        ]
      }
    ],
    "best_practices": [
      "Always scope AsyncSession to individual requests using dependency injection",
      "Use asyncio.gather for independent queries but sequential await for dependent queries",
      "Acquire database locks in consistent order to prevent deadlocks in concurrent transfers"
    ],
    "anti_patterns": [
      "Storing global session references that survive across requests",
      "Running independent queries sequentially instead of using asyncio.gather",
      "Forgetting to call session.refresh() after commit to get database-generated values"
    ],
    "faq": [
      {
        "question": "Does this skill work with synchronous SQLAlchemy?",
        "answer": "No. This skill covers async SQLAlchemy patterns with create_async_engine and AsyncSession. Synchronous patterns use different session management."
      },
      {
        "question": "What connection pool settings does this skill recommend?",
        "answer": "For asyncpg, NullPool is recommended to avoid connection reuse issues. This creates new connections per request and closes them after."
      },
      {
        "question": "Can I use these patterns with other async frameworks?",
        "answer": "Yes. The session lifecycle and transaction patterns apply to any async Python framework using SQLAlchemy async."
      },
      {
        "question": "Does this skill access my data or files?",
        "answer": "No. This skill only provides guidance through prompts. It does not read, write, or execute any code on your system."
      },
      {
        "question": "Why am I getting connection timeouts with my async code?",
        "answer": "Timeouts usually indicate connection pool exhaustion from session leaks. Check that sessions are closed properly and not stored globally."
      },
      {
        "question": "How is this different from the official SQLAlchemy async documentation?",
        "answer": "This skill provides battle-tested patterns specifically for FastAPI web applications including common pitfalls and detection commands."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
